#!/usr/bin/env ruby

trap('INT') do |status|
  exit! 128 + status
end

require 'unparser'
require 'parser/current'
require 'mutant'
require 'optparse'

class Processor < Parser::AST::Processor
  def self.call(node)
    new.process(node)
  end

  # Filter out unneded parentheses unparser (still) generates.
  def on_begin(node)
    children = node.children
    if children.one?
      process(children.first)
    else
      process_regular_node(node)
    end
  end
end

# Class to create diffs from source code
class Differ < Mutant::Differ

  def self.run(*arguments)
    new(*arguments).colorized_diff
  end

  # Return source diff
  #
  # @return [String]
  #   if there is a diff
  #
  # @return [nil]
  #   otherwise
  #
  # @api private
  #
  def diff
    diffs.map do |piece|
      Diff::LCS::Hunk.new(old, new, piece, max_length, old.length - new.length).diff(:unified) << "\n"
    end.join
  end
  memoize :diff

end # Differ

class Unparse
  class Source
    include AbstractType, Adamantium::Flat

    def success?
      original_ast == generated_ast
    end

    def error_report
      report = []
      report << Differ.run(original_ast.inspect.lines.map(&:chomp), generated_ast.inspect.lines.map(&:chomp))
      report << 'Original:'
      report << original_ast.inspect
      report << original_source
      report << 'Generated:'
      report << generated_ast.inspect
      report << generated_source
      report.join("\n")
    end

  private

    def generated_source
      Unparser.unparse(original_ast)
    end
    memoize :generated_source

    def generated_ast
      Processor.call(Parser::CurrentRuby.parse(generated_source))
    end
    memoize :generated_ast

    def original_ast
      Parser::CurrentRuby.parse(original_source)
    end
    memoize :original_ast

    class String < self
      include Concord.new(:original_source)

      def identification
        '(evaluate)'
      end
    end

    class File < self
      include Concord.new(:file_name)

      def identification
        "(#{file_name})"
      end

    private

      def original_source
        ::File.read(file_name)
      end
      memoize :original_source
    end
  end

  def self.run(*arguments)
    new(*arguments).process
  end

  def initialize(arguments)
    @sources = []

    opts = OptionParser.new do |builder|
      builder.banner = 'usage: unparse [options] FILE [FILE]'
      builder.separator('')
      builder.on('-e', '--evaluate SOURCE') do |original_source|
        @sources << Source::String.new(original_source)
      end
    end

    file_names =
      begin
        opts.parse!(arguments)
      rescue OptionParser::ParseError => error
        raise(Error, error.message, error.backtrace)
      end

    file_names.each do |file_name|
      @sources << Source::File.new(file_name)
    end
  end

  def process
    @sources.each do |source|
      process_source(source)
    end
  end

  def process_source(source)
    if source.success?
      puts "Success: #{source.identification}"
    else
      puts source.error_report
      fail "Error: #{source.identification}"
    end
  end
end

Unparse.run(ARGV)
