module Unparser
  # Preprocessor to normalize AST generated by parser
  class Preprocessor
    include Adamantium::Flat, NodeHelpers, AbstractType, Concord.new(:node, :parent_type), Procto.call(:result)

    # Return preprocessor result
    #
    # @return [Parser::AST::Node]
    #
    # @api private
    #
    abstract_method :result

    EMPTY = Parser::AST::Node.new(:empty)

    # Run preprocessor for node
    #
    # @param [Parser::AST::Node, nil] node
    #
    # @return [Parser::AST::Node, nil]
    #
    # @api private
    #
    def self.run(node, parent_type = nil)
      return EMPTY if node.nil?
      REGISTRY.fetch(node.type, [Noop]).reduce(node) do |current, processor|
        processor.call(current, parent_type)
      end
    end

    REGISTRY = Hash.new { |hash, key| hash[key] = [] }

    # Register preprocessor
    #
    # @param [Symbol] type
    #
    # @return [undefined]
    #
    # @api private
    #
    def self.register(type)
      REGISTRY[type] << self
    end
    private_class_method :register

  private

    # Visit node
    #
    # @param [Parser::AST::Node] child
    #
    # @return [undefined]
    #
    # @api private
    #
    def visit(child)
      self.class.run(child, node.type)
    end

    # Return children
    #
    # @return [Array<Parser::AST::Node>]
    #
    # @api private
    #
    def children
      node.children
    end

    # Return visited children
    #
    # @return [Array<Parser::Ast::Node>]
    #
    # @api private
    #
    def visited_children
      children.map do |node|
        if node.is_a?(Parser::AST::Node)
          visit(node)
        else
          node
        end
      end
    end

    # Noop preprocessor that just passes through noode.
    class Noop < self

      register :int
      register :str

      # Return preprocessor result
      #
      # @return [Parser::AST::Node]
      #
      # @api private
      #
      def result
        node.updated(nil, visited_children)
      end

    end # Noop

    # Preprocessor for dynamic string regexp and xtr nodes. Collapses adjacent string segments into one.
    class CollapseStrChildren < self

      register :dstr
      register :regexp
      register :xstr

      # Return preprocessor result
      #
      # @return [Parser::AST::Node]
      #
      # @api private
      #
      def result
        node.updated(nil, collapsed_children)
      end

    private

      # Return collapsed children
      #
      # @return [Array<Parser::AST::Node>]
      #
      # @api private
      #
      def collapsed_children
        chunked_children.each_with_object([]) do |nodes, aggregate|
          if nodes.size > 1 && nodes.first.type.equal?(:str)
            new_child = nodes.map { |node| node.children.first }.join
            aggregate << n(:str, [new_child], location: combined_source_map(nodes))
          else
            aggregate.concat(nodes)
          end
        end
      end
      memoize :collapsed_children

      # Return chunked children
      #
      # @return [Array<Parser::AST::Node>]
      #
      # @api private
      #
      def chunked_children
        # don't collapse children which are separated by a line break
        # (because we may need to emit a line continuation between them)
        Unparser.chunk_by(visited_children) do |prev, current|
          prev.type != current.type || different_lines?(prev, current)
        end
      end

    end # CollapseStrChildren

    # Preprocessor flattening unneeded dstr nesting. This happens when a dstr is generated from
    # implicit string concatenation, and one of the strings being concatenated is itself a dstr.
    #
    # Example: "foo" "bar #{baz}"
    #
    # Without this preprocessor, this turns into: "foo#{"bar#{baz}"}"
    # With this preprocessor, this turns into: "foobar #{baz}"
    class FlattenImplicitDSTR < self

      # No need to register :dsym, because Ruby doesn't do implicit concatenation of symbols
      register :dstr

      FLATTEN_CHILDREN = IceNine.deep_freeze([:dstr, :str])

      # Return preprocessor result
      #
      # @return [Parser::AST::Node]
      #
      # @api private
      #
      def result
        return node unless implicit_dstr?

        flat_children = children.flat_map do |child|
          child.type.equal?(:dstr) ? child.children : child
        end
        node.updated(nil, flat_children)
      end

    private

      # Test for implicit dstr
      #
      # This should only ever be true for dstr nodes that are a result of implicit concatenation
      # (see the comments on this class). Any other dstr node would have a :begin node as a child.
      #
      # @return [Boolean]
      #
      # @api private
      #
      def implicit_dstr?
        children.map(&:type).all?(&FLATTEN_CHILDREN.method(:include?))
      end

    end # FlattenImplicitDSTR

    # Preprocessor eliminating unneeded dstr nodes
    class CompactDSTR < self

      register :dstr
      register :dsym

      MAP = IceNine.deep_freeze(
        dstr: :str,
        dsym: :sym
      )

      # Return preprocessor result
      #
      # @return [Parser::AST::Node]
      #
      # @api private
      #
      def result
        if children.any? && children.all? { |child| child.type.equal?(:str) }
          node.updated(MAP.fetch(node.type), [children.map { |child| child.children.first }.join])
        else
          node
        end
      end

    end # CompactDSTR

    # Preprocessor transforming numeric nodes with infinity as value to round trippable aequivalent.
    class Infinity < self

      register :float
      register :int

      NEG_INFINITY = -(Float::INFINITY - 1)

      # Return preprocessor result
      #
      # @param [Parser::AST::Node]
      #
      # @api pirvate
      #
      def result
        value = node.children.first
        case value
        when Float::INFINITY
          s(:const, s(:const, nil, :Float), :INFINITY)
        when NEG_INFINITY
          s(:send, s(:const, s(:const, nil, :Float), :INFINITY), :-@)
        else
          node
        end
      end
    end

    # Preprocessor for begin nodes. Removes begin nodes with one child.
    #
    # This reduces the amount of complex logic needed inside unparser to emit "nice" syntax with minimal
    # tokens.
    #
    class Begin < self

      register :begin

      # Return preprocessor result
      #
      # @return [Parser::AST::Node]
      #
      # @api private
      #
      def result
        if children.one? && !parent_type.equal?(:regexp)
          visit(children.first)
        else
          Noop.call(node, parent_type)
        end
      end

    end # Begin
  end # Preprocessor
end # Unparser
